## 要求：1.设计实现输出中间代码的有关函数
2.预留代码优化有关的接口，并设计方便切换开启/关闭优化的模式

---

### **建议一：将IR生成与打印解耦 (满足要求1)**

这个建议我们之前讨论过，现在我们把它具体化。不要在一个大函数里同时构建IR对象模型并将其转换成字符串。

**设计实现：**

1.  **`LLVMIRGenerator.java`**:
    *   **职责**: 只负责一件事——接收AST和符号表，然后在**内存中**构建出一个完整的 `Module` 对象（包含`Function`, `BasicBlock`, `Instruction`等）。
    *   **主方法签名**: `public Module generate(CompUnit root, SymbolTable symbolTable)`
    *   **输出**: 返回一个顶层的 `Module` 对象。

2.  **`IRPrinter.java`**:
    *   **职责**: 也只负责一件事——接收一个`Module`对象，并将其**打印**成符合规范的、人类可读的LLVM IR字符串。
    *   **主方法签名**: `public String print(Module module)`
    *   **输出**: 返回一个`String`。

**在主驱动程序 `Compiler.java` 中的调用流程：**
```java
public class Compiler {
    public static void main(String[] args) {
        // ... 前端部分 ...
        
        // --- 中端开始 ---
        
        // 1. 生成内存中的IR对象模型
        LLVMIRGenerator irGenerator = new LLVMIRGenerator();
        Module module = irGenerator.generate(astRoot, symbolTable);
        
        // *** 这里是未来插入优化的位置 ***
        
        // 2. 将IR对象模型打印成字符串
        IRPrinter irPrinter = new IRPrinter();
        String llvmIrString = irPrinter.print(module);
        
        // 3. 将字符串写入文件
        writeToFile("output.ll", llvmIrString);
        
        // ... 后端部分 ...
    }
}
```

**好处**:
*   **模块化**: `LLVMIRGenerator` 和 `IRPrinter` 各司其职，代码清晰。
*   **满足要求1**: 你设计并实现了输出中间代码的**两个**核心函数：一个用于**构建**，一个用于**打印**。
*   **预留优化接口**: `generate()` 和 `print()` 之间的空隙，就是我们接下来要插入优化的地方。

---

### **建议二：实现一个简单的Pass管理器 (满足要求2)**

这是预留代码优化接口、并方便开关优化的**最佳实践**。

**设计实现：**

1.  **创建 `Pass` 接口 (`codegen.pass.Pass.java`)**:
    *   定义所有优化“遍”都必须遵守的契约。
    ```java
    package codegen.pass;
    import codegen.ir.Module;

    public interface Pass {
        String getName(); // 返回Pass的名字，用于调试
        void runOnModule(Module module); // 在整个模块上运行
    }
    ```
    *(注：也可以设计成 `runOnFunction(Function func)`，粒度更细)*

2.  **为每个优化创建一个具体的Pass类**:
    *   即使你现在还没实现优化，也可以先创建几个**占位符**类。
    ```java
    package codegen.pass;

    public class ConstantPropagationPass implements Pass {
        @Override public String getName() { return "Constant Propagation"; }
        @Override public void runOnModule(Module module) {
            System.err.println("Running Pass: " + getName() + " on module " + module.getName());
            // TODO: 在这里实现常量传播的具体逻辑
        }
    }

    public class DeadCodeEliminationPass implements Pass {
        @Override public String getName() { return "Dead Code Elimination"; }
        @Override public void runOnModule(Module module) {
            System.err.println("Running Pass: " + getName() + " on module " + module.getName());
            // TODO: 在这里实现死代码消除的逻辑
        }
    }
    ```

3.  **创建 `PassManager.java` (`codegen.pass.PassManager.java`)**:
    *   这是所有Pass的调度中心。
    ```java
    package codegen.pass;
    import codegen.ir.Module;
    import java.util.ArrayList;
    import java.util.List;

    public class PassManager {
        private final List<Pass> passes = new ArrayList<>();

        public void add(Pass pass) {
            this.passes.add(pass);
        }

        public void run(Module module) {
            for (Pass pass : passes) {
                pass.runOnModule(module);
            }
        }
    }
    ```

4.  **在 `Compiler.java` 中集成Pass管理器并提供开关**:
    现在，你可以利用**命令行参数**来控制是否开启优化以及开启哪些优化。

```java
public class Compiler {
    public static void main(String[] args) {
        // --- 解析命令行参数 ---
        boolean enableOptimizations = false;
        // 简单的示例：检查参数中是否有 "-O"
        for (String arg : args) {
            if (arg.equals("-O")) {
                enableOptimizations = true;
                break;
            }
        }

        // ... 前端部分 ...
        
        LLVMIRGenerator irGenerator = new LLVMIRGenerator();
        Module module = irGenerator.generate(astRoot, symbolTable);
        
        // --- 优化阶段 ---
        if (enableOptimizations) {
            System.err.println("Optimizations enabled.");
            // 1. 创建Pass管理器
            PassManager passManager = new PassManager();
            
            // 2. 添加你想要运行的优化Pass
            passManager.add(new ConstantPropagationPass());
            passManager.add(new DeadCodeEliminationPass());
            // ...可以添加更多...
            
            // 3. 运行所有已添加的Pass
            passManager.run(module);
        } else {
            System.err.println("Optimizations disabled.");
        }
        
        // --- 打印阶段 ---
        IRPrinter irPrinter = new IRPrinter();
        String llvmIrString = irPrinter.print(module);
        
        writeToFile("output.ll", llvmIrString);
    }
}
```

**好处**:
*   **满足要求2 (预留接口)**: `Pass` 接口和 `PassManager` 就是一个非常清晰、可扩展的优化接口。未来你想添加新的优化，只需要实现一个新的`Pass`类，然后在`Compiler.java`里`add`它即可。
*   **满足要求2 (开关模式)**: 通过简单的命令行参数检查，你可以非常方便地控制整个优化流程的开启或关闭。
*   **灵活性**: 你可以根据不同的优化等级（比如`-O1`, `-O2`）来决定向`PassManager`中`add`哪些不同的`Pass`组合，完美模拟了真实编译器的行为。

这个**“生成器 -> Pass管理器 -> 打印器”**的三段式流水线是一个非常经典和强大的设计，它能让你的编译器后端逻辑清晰，易于调试，并且极具扩展性。