这是一个非常现实且关键的问题。既然不能用`opt`，而自己实现一个完整的 `mem2reg` Pass 又是一个巨大的工程，你可能会感到进退两难。

别担心，我们完全可以制定一个**务实的、分层次的优化策略**。这个策略可以让你在课程项目有限的时间内，既能实现多种有效的优化，又能展示出你对编译器优化理论的深刻理解，即使你没有一个完美的SSA转换器。

---

### **核心策略：先易后难，分层优化**

我们将优化分为三个层次：**局部优化**、**全局优化（非SSA）**和**高级全局优化（需要SSA）**。你可以根据你的时间和精力，决定要实现到哪个层次。

---

### **第一层次：局部优化 (Local Optimizations)**

**“局部”的含义**：只在一个**基本块 (Basic Block)** 内部进行的优化。

**优点**:
*   **实现简单**: 不需要复杂的全局数据流分析，你只需要线性地扫描一个基本块内的指令列表。
*   **效果显著**: 能清理掉大量冗余的计算。
*   **必做项**: 这是所有优化的基础，性价比最高。

#### **你要实现的优化 Pass:**

1.  **常量折叠 (Constant Folding) 和代数化简 (Algebraic Simplification)**
    *   **实现**: 创建一个 `LocalConstantPass`。遍历基本块中的每条指令。如果是一条 `BinaryInst` (`add`, `mul`等)，检查它的操作数。
        *   如果两个操作数都是常量 -> **折叠**它。
        *   如果操作数符合代数规则 (`x+0`, `y*1`) -> **化简**它。
        *   **操作**: 用结果（一个`Constant`或另一个`Value`）调用`instruction.replaceAllUsesWith(result)`，然后把原指令删除。

2.  **局部公共子表达式消除 (Local CSE)**
    *   **实现**: 创建一个 `LocalCSEPass`。遍历基本块内的指令。
    *   **方法**: 使用一个 `HashMap<Key, Value>` 来记录当前块内已经计算过的表达式。
        *   `Key` 可以是 `(Operator, Operand1, Operand2)` 的组合。
        *   **流程**:
            a. 遇到一条指令 `inst: %c = add %a, %b`。
            b. 创建一个 `Key("add", %a, %b)`。
            c. 检查`Map`里有没有这个`Key`。
            d. **如果没有**: `map.put(key, inst)`。
            e. **如果有**: 说明之前已经计算过了（比如在`%prev_c`中），那么 `inst.replaceAllUsesWith(%prev_c)`，然后删除`inst`。

3.  **局部死代码消除 (Local DCE)**
    *   **实现**: `LocalDCEPass`。在一个基本块内部**反向**遍历指令。
    *   **方法**: 维护一个当前“活跃”的`Value`集合 `Set<Value> liveSet`。
        *   **流程**:
            a. 从块的最后一条指令（通常是`br`或`ret`）开始。它的操作数都是活跃的，加入`liveSet`。
            b. 向上遍历到指令 `inst: %c = add %a, %b`。
            c. **检查**: `inst`的计算结果 `%c` 是否在 `liveSet` 中？
            d. **如果是**: 说明 `%c` 将来会被用到。那么 `inst` 是有用的。将 `inst` 的操作数 `%a` 和 `%b` 加入 `liveSet`，并从 `liveSet` 中移除 `%c`（因为它的生命周期在这里定义了）。
            e. **如果不是**: 说明 `%c` 在这个块的后续部分没有被使用。那么 `inst` 就是死代码（前提是它没有副作用），可以直接删除。

---

### **第二层次：全局数据流分析与优化 (无需SSA)**

**“全局”的含义**: 跨越多个基本块，在整个函数的**控制流图 (CFG)** 上进行的优化。

**优点**:
*   能实现更强大的优化，比如循环优化。
*   让你真正实践编译原理课程中的数据流分析理论。

#### **你要实现的优化 Pass:**

1.  **活跃变量分析 (Live Variable Analysis)**
    *   **这是基础**: 这是很多全局优化的基础，也是实现图着色寄存器分配的前提。
    *   **实现**: 创建一个 `LiveVariableAnalysisPass`。
    *   **方法**: 这是一个**反向**的数据流分析问题。你需要为每个基本块计算 `in[B]` 和 `out[B]` 集合。
        *   `out[B] = Union(in[S])` for all successors `S` of `B`。
        *   `in[B] = use[B] U (out[B] - def[B])`。
    *   你需要迭代计算，直到所有块的 `in` 和 `out` 集合不再变化（达到不动点）。
    *   **产出**: 每个基本块的出口处和入口处的活跃变量集合。

2.  **全局死代码消除 (Global DCE)**
    *   **实现**: 在`LiveVariableAnalysisPass`的结果之上，创建一个 `GlobalDCEPass`。
    *   **方法**: 遍历所有指令 `inst: %c = ...`。如果 `%c` **不在** `inst` 所在位置的**活跃变量集合**中，那么这条指令就是死的（前提是无副作用），可以删除。

3.  **循环不变代码外提 (Loop-Invariant Code Motion, LICM)**
    *   **实现**: 这是一个更高级的Pass，`LICMPass`。
    *   **前提**:
        a. 你需要先实现一个**循环查找 (Loop Detection)** Pass，它通过在CFG中寻找“回边”（back edges）来识别出所有的循环。
        b. 你需要实现**到达定义分析 (Reaching Definitions Analysis)**。
    *   **方法**:
        a. 找到一个循环。
        b. 遍历循环内部的所有指令。
        c. 对于一条指令 `inst: %c = add %a, %b`，检查它的操作数 `%a` 和 `%b` 的定义是否都**在循环外部**（通过到达定义分析）。
        d. 如果是，并且这条指令满足其他安全条件（比如不会有副作用，其所在块是循环的唯一出口等），那么就可以将这条指令**移动**到循环入口前的一个新创建的“前置头部块”（preheader）中。

---

### **第三层次：为SSA做准备 (高级)**

如果你完成了以上所有，并且还有时间和精力，可以尝试实现一个**简化版的 `mem2reg`**。

*   **目标**: 只处理最简单的情况，比如一个`if-else`语句中对同一个变量的赋值。
*   **方法**:
    1.  在 `visit(IfStmt)` 生成IR时，不要立即生成`alloca`。
    2.  分别递归访问 `then` 块和 `else` 块。
    3.  在访问时，记录下来哪些变量在这些块中被赋值了。
    4.  在`merge`块的开头，为你发现在两个分支中都被赋值的变量，**手动创建一个`PhiNode`对象**。
    5.  这个 `PhiNode` 的来源就是你在 `then` 块和 `else` 块中记录的那个新值。

这虽然不是一个通用的SSA转换算法，但能让你在受限的场景下利用`phi`节点的优势。

---

### **给你的最终路线图**

1.  **[必做] 搭建好 `PassManager` 框架**。
2.  **[必做] 实现第一层次的全部局部优化**：常量折叠/化简，局部CSE，局部DCE。这些是性价比最高的优化，能让你的IR质量有一个大的飞跃。
3.  **[推荐] 实现第二层次的数据流分析**：至少完整地实现**活跃变量分析**。这不仅能让你实现全局DCE，更是后续寄存器分配的基础，一举多得。
4.  **[挑战] 尝试实现 LICM**。这是课程项目中一个非常亮眼的加分项。
5.  **[可选] 尝试实现简化版的`phi`节点生成**。

通过这个分层次的路线，你可以根据项目进度灵活调整你的目标。即使你只完成了第一层次，你的编译器也已经具备了相当不错的优化能力。完成了第二层次，你的项目就已经达到了一个非常高的高度。