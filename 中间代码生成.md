好的，我们来制定一个完整的、分阶段的构建路线图。这个路线图将指导你从现有的、经过语义分析的AST，一步步地构建出一个功能完整、结构清晰、并且最终能生成兼容Clang 12的LLVM IR的后端。

我们将采用**“先在内存中构建IR对象模型，最后再打印成字符串”**的最佳实践。

---

### **最终目标**

你的 `Compiler.java` 的主流程将变成这样：

1.  **词法分析 -> Token流**
2.  **语法分析 -> AST**
3.  **语义分析 (`SemanticVisitor`) -> 检查过的AST + 填充好的符号表**
4.  **如果有错误，直接输出错误，程序终止，否则继续往下
5.  **IR生成 (`LLVMIRGenerator`) -> 内存中的LLVM Module对象**
6.  **IR打印 (`IRPrinter`) -> 符合Clang 12语法的 `.ll` 文本文件**

---

### **阶段一：奠定基石 - 创建IR数据结构 **

**目标**: 在一个新的`codegen.ir`包中，定义出能够描述LLVM IR所有组成部分的核心Java类。

1.  **创建包**: 在`compiler`源码下创建`codegen.ir`包。

2.  **创建类型系统 (`Type.java`)**:
    *   创建一个`Type`基类和几个子类，用来表示LLVM的类型。
    *   `IntegerType.java` (例如 `i32`)
    *   `VoidType.java`
    *   `PointerType.java` (例如 `i32*`, `[10 x i32]*`)
    *   `ArrayType.java` (例如 `[10 x i32]`)
    *   `FunctionType.java`

3.  **创建`Value`继承体系 (`Value.java`, `User.java`, `Constant.java`)**:
    *   `Value.java`: 所有IR元素的抽象基类。它应该包含一个`Type`成员和一个`String name`（用于调试）。
    *   `User.java`: 继承`Value`。代表可以“使用”其他`Value`的东西。它内部应该有一个`List<Value> operands`来存储它使用的操作数。
    *   `Constant.java`: 继承`Value`。用于表示常量，比如`ConstantInt.java`。

4.  **创建指令体系 (`Instruction.java`和子类)**:
    *   在`codegen.ir.inst`包下创建`Instruction.java`，它继承自`User`。
    *   为每一种需要的LLVM指令创建具体的子类：
        *   `AllocaInst.java`
        *   `StoreInst.java`
        *   `LoadInst.java`
        *   `BinaryInst.java` (用于 `add`, `sub`, `icmp` 等)
        *   `GetElementPtrInst.java` (GEP)
        *   `ReturnInst.java`
        *   `BranchInst.java` (条件和无条件跳转)
        *   `CallInst.java`

5.  **创建顶层结构 (`BasicBlock.java`, `Function.java`, `Module.java`)**:
    *   `BasicBlock.java`: 继承`Value`。包含一个`List<Instruction>`，以及`BasicBlock trueSuccessor`和`falseSuccessor`成员，用于在内存中构建CFG。
    *   `Function.java`: 继承`Value`。包含一个`List<BasicBlock>`，一个入口块`entryBlock`，参数列表等。
    *   `Module.java`: 整个编译单元的顶层容器。包含一个`List<Function>`和全局变量列表。

---

### **阶段二：实现IR生成器 (`LLVMIRGenerator`) **

**目标**: 创建一个`LLVMIRGenerator.java`，它会遍历AST，并利用第一阶段创建的数据结构，在内存中构建出一个完整的`Module`对象。

1.  **创建 `LLVMIRGenerator.java`**: 在`codegen`包下创建该类。它需要维护以下状态：
    *   `Module module`: 当前正在构建的模块。
    *   `Function currentFunction`: 当前正在构建的函数。
    *   `BasicBlock currentBlock`: 当前正在插入指令的基本块。
    *   `SymbolTable symbolTable`: 从语义分析器传入的符号表。
    *   `Map<Symbol, Value> symbolValueMap`: 关键的映射表！用于将源语言的符号（来自`SymbolTable`）映射到LLVM的`Value`对象（通常是`alloca`指令返回的指针）。

2.  **实现 `visit` 方法**:
    *   **`visit(Expression node)` -> `Value`**: 表达式的`visit`方法必须返回一个`Value`对象。
        *   `visit(NumberLiteral)`: 返回一个`ConstantInt`对象。
        *   `visit(LVal)`: 从`symbolValueMap`中找到变量的指针，创建一个`LoadInst`对象，将它加入`currentBlock`，然后返回这个`LoadInst`对象（因为它本身也是一个`Value`）。
        *   `visit(BinaryExp)`: 递归调用`visit`获取左右操作数的`Value`对象，创建一个`BinaryInst`对象，加入`currentBlock`，并返回这个`BinaryInst`。
    *   **`visit(Statement node)` -> `void`**: 语句的`visit`方法不返回值，它只负责修改CFG。
        *   `visit(AssignStmt)`: `visit`右侧表达式得到`Value`，找到左侧变量的指针，创建一个`StoreInst`并加入`currentBlock`。
        *   `visit(IfStmt)`: **这是CFG构建的核心！**
            a. 创建`thenBlock`, `elseBlock`, `mergeBlock`三个新的`BasicBlock`对象。
            b. 在`currentBlock`的末尾添加一个`BranchInst`（条件跳转）。
            c. 设置`currentBlock`的`trueSuccessor`和`falseSuccessor`。
            d. `currentBlock = thenBlock;` // 切换当前块
            e. 递归`visit` `then`分支的语句（它们会被加入`thenBlock`）。
            f. 在`thenBlock`末尾添加一个无条件跳转到`mergeBlock`的`BranchInst`。
            g. 对`elseBlock`重复此过程。
            h. `currentBlock = mergeBlock;` // 将插入点移到合并块，继续后续代码生成。
    *   **`visit(FuncDef)` -> `void`**:
        a. 创建一个新的`Function`对象并设为`currentFunction`。
        b. 创建`entry` `BasicBlock`并设为`currentBlock`。
        c. **关键**: 在`entry`块的**最顶端**，遍历函数内所有局部变量声明，为它们一一创建`AllocaInst`，并填充`symbolValueMap`。
        d. 遍历函数体的语句，调用它们的`visit`方法。

---

### **阶段三：实现IR打印器 (`IRPrinter`) (2-3天)**

**目标**: 创建一个`IRPrinter.java`，它可以接收一个`Module`对象，并将其“翻译”成符合Clang 12规范的、人类可读的`.ll`文本文件。

1.  **创建 `SlotTracker.java`**:
    *   实现这个辅助类，它的核心是一个`Map<Value, Integer>`。
    *   提供一个方法`scan(Function function)`，它会遍历一个函数内的所有需要编号的`Value`对象（参数、指令结果），并为它们分配从0开始的连续数字。

2.  **创建 `IRPrinter.java`**:
    *   它接收一个`Module`对象。
    *   主方法 `printModule()` 会遍历模块中的所有函数。
    *   `printFunction(Function func)`方法：
        a. **首先**，创建一个新的`SlotTracker`实例，并调用`tracker.scan(func)`来预计算所有编号。
        b. 打印函数签名`define i32 @func_name(...) {`。
        c. 遍历函数中的所有`BasicBlock`。
        d. `printBasicBlock(BasicBlock block)`方法：
            i. 打印块的标签，例如`entry:`。
            ii. 遍历块中的所有`Instruction`。
            iii. `printInstruction(Instruction inst)`方法：这是最复杂的部分。你需要用一个大的`switch`或`if-else if`来判断指令的类型（`inst instanceof AllocaInst`等）。
            iv. **关键**: 在打印指令时，对于指令自身（如果它有返回值）和它的所有操作数（`Value`对象），你都需要**调用`slotTracker.getSlot(value)`来获取它的数字编号**，然后拼接成`%0`, `%1`这样的字符串。
            v. 对于常量，直接打印其值。
            vi. **遵循Clang 12的类型化指针语法**：在打印`store`, `load`, `getelementptr`时，你需要从操作数的`Type`对象中获取信息，并明确打印出指针类型，例如`i32*`或`[10 x i32]*`。

---

### **总结：你的行动清单**

1.  **[基建]** 按照**阶段一**，在`codegen.ir`包中把所有数据结构类都创建好。这是你后续工作的基础。
2.  **[生成]** 按照**阶段二**，开始实现`LLVMIRGenerator`。从最简单的表达式和赋值开始，确保它们能正确地构建出`Instruction`对象并添加到`BasicBlock`中。最后再攻克`if`和`for`等控制流。
3.  **[打印]** 按照**阶段三**，实现`IRPrinter`。先实现`SlotTracker`，然后实现打印逻辑。你可以先打印简单的指令，逐步增加对复杂指令的支持。
4.  **[测试]** 编写一个简单的C文件，手动在Godbolt上查看Clang 12 (`-O0`)生成的IR，然后运行你的编译器，对比你的输出和Godbolt的输出。它们的名字（`%0`）可能不同，但**结构和指令类型**应该是一致的。

这个路线图将引导你构建一个健壮、可维护、并且为未来优化打下坚实基础的编译器后端。