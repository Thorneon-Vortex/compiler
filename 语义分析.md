
---

### 总体策略：在语法分析器中嵌入语义动作

 `Parser` 目前是一个“识别器”，它能判断代码结构是否符合文法。我们将把它升级为一个“翻译器”，在识别语法的**同时**，执行以下**语义动作**：
1.  **管理作用域**：进入/退出函数或代码块时，创建/销毁对应的符号表。
2.  **收集声明信息**：遇到变量、常量、函数声明时，将它们的详细信息（名字、类型、作用域等）填入符号表。
3.  **进行语义检查**：遇到使用变量或调用函数时，查询符号表，检查是否合法（如：是否已定义、类型是否匹配等）。

---

### 详细实施步骤

#### 第1步：设计符号表的核心数据结构

需要创建两个关键的类来代表符号和符号表。我们可以参考你PPT中的设计，并针对Java进行实现。

**`Symbol.java` (符号条目)**
这个类代表符号表中的一条记录。

```java
// 可以放在一个新的包，例如 symbol
package symbol;

import java.util.List;

public class Symbol {
    private String name;        // 符号名
    private String typeName;    // 类型名称 (例如 "ConstInt", "IntFunc")
    private int scopeId;        // 所在作用域ID

    // --- 可选但强烈推荐的额外信息 ---
    private boolean isConstant; // 是否是常量
    private int lineNum;        // 声明的行号
    
    // 仅函数需要
    private List<String> paramTypeNames; // 参数类型列表
    
    // 构造函数 (可以根据需要创建多个)
    public Symbol(String name, String typeName, int scopeId, int lineNum) {
        this.name = name;
        this.typeName = typeName;
        this.scopeId = scopeId;
        this.lineNum = lineNum;
        this.isConstant = typeName.startsWith("Const");
    }
    
    // for functions
    public Symbol(String name, String typeName, int scopeId, int lineNum, List<String> paramTypeNames) {
        this(name, typeName, scopeId, lineNum);
        this.paramTypeNames = paramTypeNames;
    }

    // Getters
    public String getName() { return name; }
    public String getTypeName() { return typeName; }
    public int getScopeId() { return scopeId; }
    public boolean isConstant() { return isConstant; }
    public int getLineNum() { return lineNum; }
    public List<String> getParamTypeNames() { return paramTypeNames; }

    @Override
    public String toString() {
        return scopeId + " " + name + " " + typeName;
    }
}
```

**`SymbolTable.java` (单个作用域的符号表)**
这个类代表一个作用域。

```java
// symbol/SymbolTable.java
package symbol;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SymbolTable {
    private int id;
    private SymbolTable parent; // 指向外层作用域
    
    // 用于快速查找，检查重定义等
    private Map<String, Symbol> symbols = new HashMap<>(); 
    
    // 用于按声明顺序输出，满足题目要求
    private List<Symbol> orderedSymbols = new ArrayList<>(); 

    public SymbolTable(int id, SymbolTable parent) {
        this.id = id;
        this.parent = parent;
    }

    // 插入符号，同时处理重定义错误
    public boolean addSymbol(Symbol symbol) {
        if (symbols.containsKey(symbol.getName())) {
            return false; // 重定义
        }
        symbols.put(symbol.getName(), symbol);
        orderedSymbols.add(symbol);
        return true;
    }
    
    // 在当前作用域查找符号
    public Symbol findInCurrentScope(String name) {
        return symbols.get(name);
    }
    
    // Getters
    public int getId() { return id; }
    public SymbolTable getParent() { return parent; }
    public List<Symbol> getOrderedSymbols() { return orderedSymbols; }
}
```

#### 第2步：创建符号表管理器

创建一个单例或由 `Parser` 持有的管理器，来统一处理所有作用域的进入、退出和查找。

**`SymbolTableManager.java`**

```java
// symbol/SymbolTableManager.java
package symbol;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class SymbolTableManager {
    private SymbolTable currentScope; // 指向当前作用域
    private int nextScopeId = 1;      // 用于分配下一个作用域ID
    
    // 存储所有创建过的符号表，用于最终输出
    private List<SymbolTable> allTables = new ArrayList<>(); 

    public SymbolTableManager() {
        // 构造时自动创建全局作用域
        enterScope(); 
    }

    // 进入新作用域
    public void enterScope() {
        SymbolTable newScope = new SymbolTable(nextScopeId++, currentScope);
        currentScope = newScope;
        allTables.add(newScope);
    }

    // 退出当前作用域
    public void exitScope() {
        if (currentScope != null) {
            currentScope = currentScope.getParent();
        }
    }

    // 添加符号到当前作用域
    public boolean addSymbol(Symbol symbol) {
        return currentScope.addSymbol(symbol);
    }

    // 从当前作用域开始，沿着作用域链向上查找符号
    public Symbol lookup(String name) {
        SymbolTable scope = currentScope;
        while (scope != null) {
            Symbol symbol = scope.findInCurrentScope(name);
            if (symbol != null) {
                return symbol;
            }
            scope = scope.getParent();
        }
        return null; // 未找到
    }

    public int getCurrentScopeId() {
        return currentScope.getId();
    }
    
    // 用于生成 symbol.txt 的方法
    public void generateOutput(PrintWriter writer) {
        // allTables.sort(Comparator.comparingInt(SymbolTable::getId)); // 已经是按ID顺序添加的
        for (SymbolTable table : allTables) {
            for (Symbol symbol : table.getOrderedSymbols()) {
                writer.println(symbol);
            }
        }
    }
}
```

#### 第3步：将符号表管理器集成到 `Parser` 中

现在，我们需要让你的 `Parser` "拥有" 并使用这个管理器。

**修改 `Parser.java`**
```java
// Parser.java

import symbol.Symbol;
import symbol.SymbolTableManager;
// ... 其他 import

public class Parser {
    // ... 已有成员 ...
    private final SymbolTableManager symbolTableManager; // 新增成员

    // 构造函数
    public Parser(List<Token> tokens, PrintWriter outputWriter) {
        this.tokens = tokens;
        this.outputWriter = outputWriter;
        this.currentToken = tokens.get(0);
        this.symbolTableManager = new SymbolTableManager(); // 初始化管理器
    }

    // ... 其他方法 ...

    // 在Compiler.java中也需要修改
    public SymbolTableManager getSymbolTableManager() {
        return symbolTableManager;
    }
}
```

#### 第4步：在 `parseXXX()` 方法中嵌入语义动作

这是最关键的一步。我们需要找到代码中**定义**和**使用**符号的地方，并插入相应的符号表操作和检查。

**1. 管理作用域**

*   **`parseBlock()`**: 这是最典型的作用域。
    ```java
    private Node parseBlock() {
        consume(); // {
        symbolTableManager.enterScope(); // *** 进入新作用域 ***
        
        while (peek() != TokenType.RBRACE) {
            parseBlockItem();
        }
        
        consume(); // }
        symbolTableManager.exitScope(); // *** 退出作用域 ***
        
        printSyntaxComponent("Block");
        return null;
    }
    ```
*   **`parseFuncDef()` / `parseMainFuncDef()`**: 函数本身及其参数也引入了新的作用域。
    ```java
    private Node parseFuncDef() {
        // ... 解析 FuncType ...
        Token funcNameToken = currentToken; // ** 捕获函数名Token **
        consume(); // Ident
        
        // ** 添加函数名到外层作用域 **
        // (此处需要提前收集好返回类型和参数类型，稍微复杂，可以先简化)
        
        consume(); // (
        symbolTableManager.enterScope(); // *** 进入函数作用域 ***
        
        if (peek() == TokenType.INTTK) {
            parseFuncFParams(); // 在新作用域内解析参数
        }
        
        consume(TokenType.RPARENT, "j");
        
        parseBlock(); // Block自身会再次 enter/exit scope，这是嵌套的
                      // 但函数体和参数是在同一个作用域，所以Block的enter/exit是正确的
        
        // 注意：函数作用域在 parseBlock 结束后就退出了，这不完全对
        // 修正：Block不应该自己管理函数级别的作用域
        // 我们在函数定义这里统一管理
        
        // *** 正确的作用域管理方式 ***
        // private Node parseFuncDef() {
        //     // ... 解析 FuncType, Ident ...
        //     consume(); // (
        //     symbolTableManager.enterScope(); // ** 进入函数作用域 **
        //     // ... 解析 FuncFParams ...
        //     consume(); // )
        //     
        //     // Block不再自己enter/exit
        //     parseBlock_noScopeManagement(); // 需要创建一个新版本的parseBlock
        //     
        //     symbolTableManager.exitScope(); // ** 退出函数作用域 **
        // }
        // 鉴于你的文法 Block → '{' { BlockItem } '}'，每个 Block 都是新作用域是正确的。
        // 所以我们保持 parseBlock 的实现不变，这是符合C/Java语义的。
        
        printSyntaxComponent("FuncDef");
        return null;
    }
    ```
    **结论**：保持现有的 `parseBlock` 实现，它为每个 `{...}` 创建新作用域，这是正确的。

**2. 处理声明 (填表 & 查重)**

*   **`parseConstDef()`**:
    ```java
    private Node parseConstDef() {
        Token identToken = currentToken; // ** 捕获标识符Token **
        consume(); // Ident
        
        boolean isArray = false;
        if (peek() == TokenType.LBRACK) {
            isArray = true;
            // ... 解析数组维度 ...
        }
        
        consume(); // '='
        parseConstInitVal();

        // *** 语义动作 ***
        String typeName = isArray ? "ConstIntArray" : "ConstInt";
        Symbol symbol = new Symbol(identToken.value(), typeName, 
                                   symbolTableManager.getCurrentScopeId(), identToken.lineNum());
        if (!symbolTableManager.addSymbol(symbol)) {
            // 添加失败，说明重定义
            errors.add(new SyntaxError(identToken.lineNum(), "b")); // ** 错误b：名字重定义 **
        }

        printSyntaxComponent("ConstDef");
        return null;
    }
    ```
*   **`parseVarDef()`**: 逻辑与 `parseConstDef` 非常相似。
    ```java
    private Node parseVarDef() {
        Token identToken = currentToken;
        // ... (解析 Ident 和可能的数组维度) ...

        // *** 语义动作 ***
        // 假设已经有 isStatic 和 isArray 标志
        // String typeName = ... (根据 isStatic 和 isArray 决定 "Int", "IntArray", "StaticInt" 等)
        // Symbol symbol = new Symbol(...)
        // if (!symbolTableManager.addSymbol(symbol)) {
        //     errors.add(new SyntaxError(identToken.lineNum(), "b"));
        // }

        printSyntaxComponent("VarDef");
        return null;
    }
    ```
*   **`parseFuncFParam()` (函数形参)**: 也是一种声明。
    ```java
    private Node parseFuncFParam() {
        parseBType();
        Token identToken = currentToken;
        consume(); // Ident
        // ... (处理可能的 '[]') ...

        // *** 语义动作 ***
        // String typeName = ... ("Int" or "IntArray")
        // Symbol symbol = new Symbol(...)
        // if (!symbolTableManager.addSymbol(symbol)) {
        //     errors.add(new SyntaxError(identToken.lineNum(), "b"));
        // }
        
        printSyntaxComponent("FuncFParam");
        return null;
    }
    ```

**3. 处理使用 (查表 & 语义检查)**

*   **`parseLVal()`**:
    ```java
    private Node parseLVal() {
        Token identToken = currentToken;
        consume(); // Ident

        // *** 语义动作：检查未定义错误 ***
        Symbol symbol = symbolTableManager.lookup(identToken.value());
        if (symbol == null) {
            errors.add(new SyntaxError(identToken.lineNum(), "c")); // ** 错误c：未定义的名字 **
        }

        while (peek() == TokenType.LBRACK) {
            // ...
        }
        
        // ** 检查对常量的赋值 (错误h) **
        // 这个检查不能在这里做，因为这里只解析LVal，不知道后面是不是赋值。
        // 检查应该放在 parseStmt 中。

        printSyntaxComponent("LVal");
        return null; // 这里应该返回一个LVal的AST节点，节点里包含查找到的symbol
    }
    ```
*   **`parseStmt()` 中处理赋值**:
    ```java
    // ... 在 parseStmt 的 default case 中
    if (isAssign) {
        // LVal 的解析需要返回信息
        // 假设我们修改 parseLVal 返回查找到的 Symbol
        // Symbol lvalSymbol = parseLVal(); // 修改 parseLVal 返回值
        
        // 简化版：在解析完LVal后，立即回头看
        Token lvalToken = tokens.get(currentPos - 1); // 这是一个小技巧
        Symbol lvalSymbol = symbolTableManager.lookup(lvalToken.value());
        if (lvalSymbol != null && lvalSymbol.isConstant()) {
            errors.add(new SyntaxError(lvalToken.lineNum(), "h")); // ** 错误h：修改常量 **
        }

        consume(); // =
        parseExp();
    }
    // ...
    ```
*   **`parseUnaryExp()` 中处理函数调用**:
    ```java
    private Node parseUnaryExp() {
        if (peek() == TokenType.IDENFR && peek(1) == TokenType.LPARENT) {
            Token funcToken = currentToken;
            consume(); // Ident
            consume(); // '('

            // *** 语义动作：检查函数定义 ***
            Symbol funcSymbol = symbolTableManager.lookup(funcToken.value());
            if (funcSymbol == null) {
                errors.add(new SyntaxError(funcToken.lineNum(), "c")); // ** 错误c：未定义的名字 **
            } else if (!funcSymbol.getTypeName().endsWith("Func")) {
                // 查到了，但不是函数
                // 题目没要求这个错误，但这是个典型的语义错误
            }

            // *** 语义动作：检查参数匹配 ***
            if (peek() != TokenType.RPARENT) {
                // List<String> argTypes = parseFuncRParams(); // 让它返回参数类型列表
                // if (funcSymbol != null && funcSymbol.getTypeName().endsWith("Func")) {
                //    if (argTypes.size() != funcSymbol.getParamTypeNames().size()) {
                //        errors.add(new SyntaxError(funcToken.lineNum(), "d")); // ** 错误d：参数个数不匹配 **
                //    } else {
                //        // 逐个比较类型 (错误e)
                //    }
                // }
            } else {
                // 无参数调用
                // if (funcSymbol != null && !funcSymbol.getParamTypeNames().isEmpty()) {
                //     errors.add(new SyntaxError(funcToken.lineNum(), "d"));
                // }
            }

            consume(TokenType.RPARENT, "j"); // ')'
        }
        // ... else if ...
    }
    ```

#### 第5步：调整主程序和输出逻辑

最后，修改 `Compiler.java` 来处理最终的输出。

```java
// Compiler.java
public class Compiler {
    public static void main(String[] args) {
        // ... 文件路径定义 ...
        String inputFile = "testfile.txt";
        String symbolFile = "symbol.txt"; // ** 修改输出文件名 **
        String errorFile = "error.txt";

        // ...
            // ===================================
            //         2. 语法 & 语义分析阶段
            // ===================================
            // 注意：因为要生成symbol.txt，我们不再使用StringWriter
            // 而是直接传递一个空的writer给Parser，让它不要输出语法树

            // 创建一个什么都不做的PrintWriter
            PrintWriter dummyWriter = new PrintWriter(new java.io.OutputStream() {
                public void write(int b) {}
            });

            Parser parser = new Parser(tokens, dummyWriter);
            parser.parse();

            allErrors.addAll(parser.getErrors());

            // ===================================
            //         3. 决策与输出阶段
            // ===================================
            if (!allErrors.isEmpty()) {
                // ... (输出 error.txt 的逻辑保持不变) ...
            } else {
                // ** 新增：如果没有任何错误，则输出 symbol.txt **
                try (PrintWriter symbolWriter = new PrintWriter(symbolFile, StandardCharsets.UTF_8)) {
                    SymbolTableManager manager = parser.getSymbolTableManager();
                    manager.generateOutput(symbolWriter);
                }
                System.out.println("Compilation successful. Symbol table written to " + symbolFile);
            }
        // ...
    }
}

```

### 总结与下一步

1.  **创建 `symbol` 包**，并在其中实现 `Symbol.java`, `SymbolTable.java`, `SymbolTableManager.java`。
2.  **修改 `Parser.java`**，添加 `SymbolTableManager` 成员，并在构造函数中初始化。
3.  **在 `Parser.java` 中**，找到所有作用域变化的入口和出口（主要是 `parseBlock`, `parseFuncDef`），调用 `enterScope()` 和 `exitScope()`。
4.  **在 `Parser.java` 中**，找到所有声明语句（`parseConstDef`, `parseVarDef`, `parseFuncFParam`），捕获声明的 `Token`，创建 `Symbol` 对象，并调用 `symbolTableManager.addSymbol()`，同时处理重定义错误 `b`。
5.  **在 `Parser.java` 中**，找到所有使用标识符的地方（`parseLVal`, 函数调用），调用 `symbolTableManager.lookup()`，处理未定义错误 `c` 和常量赋值错误 `h` 等。
6.  **修改 `Compiler.java`** 的主流程，根据错误列表是否为空，决定是输出 `error.txt`还是调用 `SymbolTableManager` 的方法生成 `symbol.txt`。

这个过程比较繁琐，需要细心。建议从最简单的部分开始，比如只处理全局变量的声明和作用域，然后再逐步添加函数、嵌套块和更复杂的错误检查。祝你成功！